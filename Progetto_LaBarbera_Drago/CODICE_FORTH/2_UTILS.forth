
DECIMAL

\ PAROLA CHE RITORNA IL VALORE CONTENUTO NEL REGISTRO TIME
\ ( -- TIME )
: TIMESTAMP TIMER @ ; 

\ RITARDO DIPENDENTE DAL TEMPO
\ ( TEMPO_MICROSEC -- )
: DELAY TIMESTAMP BEGIN 2DUP TIMESTAMP SWAP - <= UNTIL 2DROP ;


\PAROLA CHE DATO IN INPUT IL GPIO DA TRATTARE (ES. 17) RESISTUISCE L'INDIRIZZO DEL GPFSEL(N) ADATTO (ES. 3F200004 ---> GPFSEL1) E NUOVAMENTE L'INPUT DATO
\ (GPIO -- GPIO INDIRIZZO )
: ?GPIOFSEL DUP 10 / 4 * GPIOFSEL + ;

\ PAROLA CHE DATI IN INPUT IL GPIO DA TRATTARTE (ES. 17) RESISTUISCE L'INDIRIZZO ???
\( GPIO -- INDIRIZZO VAL)
: ?PIN ?GPIOFSEL SWAP 10 MOD 3 *  2DUP 7 SWAP LSHIFT INVERT OVER @ AND SWAP ! ;


\ ( INDIRIZZO VAL VALORE_LOGICO -- )
: ABIL SWAP LSHIFT OVER @ OR SWAP !  ;

\ PAROLA CHE IMPOSTA IL VALORE LOGICO DEI PIN 
\ IN INPUT (000) QUINDI 0, IN OUTPUT (001) QUINDI 1 O IN ALT5 (010) QUINDI 2
\ (GPIO VALORE_LOGICO -- ) (ES.  17 1 ABIL_PIN)
: ABILPIN SWAP ?PIN ROT ABIL ;


\SETTA IL REGISTRO GPIOSET
\(N1 -- )
: SET GPIOSET ! ;

\SETTA IL REGISTRO GPIOCLR
\(N1 -- )
: CLR GPIOCLR ! ;

\ PAROLE CHE IMPOSTANO IL VALORE LOGICO 1 NEI REGISTRI GPIOSET E GPIOCLR PER UN DETERMINATO GPIO
\ (GPIO -- )
: SETGPIO 1 SWAP LSHIFT SET ;
\ (GPIO --)
: CLRGPIO 1 SWAP LSHIFT CLR ;


\ PAROLA CHE DETERMINA IL VALORE LOGICO DEL GPIO PASSATO IN INPUT
\ (GPIO -- LOGVAL)
: READLEV 1 SWAP LSHIFT GPIOLEV @ AND 0 = IF 0 ELSE 1 THEN ;


\ PAROLE CHE INCREMENTANO O DECREMENTANO IL VALORE DI UN CONTATORE
\ (VALORE VARIABILE -- )
: DECC DUP @ ROT - SWAP ! ;
: ADDC DUP @ ROT + SWAP ! ;

