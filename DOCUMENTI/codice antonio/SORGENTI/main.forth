
: TASTI_KEYPAD S" 123A456B789C*0#D" ;
: MEX_AVVIO S" SELEZIONARE.PRODOTTO    " ;
: MEX_EROGAZIONE S" EROGAZIONE.IN CORSO" ;
: MEX_CONFERMA S" PREMERE D PER.CONFERMARE  " ;
: MEX_ERROR S" CODICE ERRATO" ;
: MEX_NO_DISP S" PRODOTTO.ESAURITO" ; 

: START_DISPLAY CLEAR_DISPLAY MEX_AVVIO STAMPA_MESSAGGIO ;

\ VARIABILE UTILIZZATA PER RESETTARE IL DISTRIBUTORE
\ SE NON SI CONFERMA IL PRODOTTO ENTRO 6 SECONDI
VARIABLE FLAG 
0 FLAG !

\ CREAZIONE DI UNA VARIABILE CHE CONTERRÁ IL VALORE CORRISPONDENTE
\ AI TRE TASTI PREMUTI NEL TASTIERINO NUMERICO
CREATE CODICE 2 ALLOT ALIGN


\ PAROLA CHE CONTIENE LE TERNE DI CODICE 
\ AMMISSIBILE PER L'EROGAZIONE DEL PRODOTTO
: PRODOTTI S" 12A13A22B23B" ;


\ CONTERRÁ L'INDICE 0, 1, 2 RELATIVI A CODICE UTILIZZATO PER MUOVERSI ALL'INTERNO DI ESSO
VARIABLE INDICE
\ INIZIALIZZA I TRE BYTE DI CODICE A -1
\ ( -- )
: RESTART_CODICE 0 CONTATORE !
				 BEGIN 
					-1 CODICE CONTATORE @ + C!
					1 CONTATORE ++I
				CONTATORE @ 3 = UNTIL 
				0 INDICE ! ;

RESTART_CODICE

\ VARIABLE UTILIZZATA PER USCIRE DALLA FUNZIONE MAIN
VARIABLE SPEGNI
0 SPEGNI !


\ VARIABLI CONTENENTI I VALORI CORRISPONDENTI AGLI INDICI DI RIGA
\ E DI COLONNA DEL TASTO PREMUTO SUL KEYPAD
VARIABLE COLONNA
VARIABLE RIGA

\ FUNZIONE CHE CALCOLA L'INDICE DI POSIZIONE DEI CHAR 
\ CORRISPONDENTI ALLA STRINGA TASTI_KEYPAD
\ ( -- INDICE_POSIZIONE )
: TASTO_PREMUTO RIGA @ 2 - 4 * COLONNA @ 6 - + ;


\ FUNZIONE CHE AGGIUNGE ALLA PAROLA CODE IL VALORE DEL TASTO PREMUTO
\ NEL KEYPAD E LO MOSTRA NEL DISPLAY LCD
: MEMORIZZA_TASTO TASTO_PREMUTO DUP  
				  12 = IF 			\ SE VIENE PREMUTO * CHE CORRISPONDE ALLA POSIZONE 12 
					START_DISPLAY 	\RESETTA IL DISPLAY LCD
					RESTART_CODICE 	\ CANCELLA I TASTI GIA PREMUTI E MEMORIZZATI IN CODICE
					DROP
				  ELSE 
					DUP 14 = IF 		\ SE VIENE PREMUTO # CHE CORRISPONDE ALLA POSIZONE 14 
						1 SPEGNI ! 		\ IMPOSTA LA CONDIZIONE PER USCIRE DAL LOOP DEL MAIN
						CLEAR_DISPLAY 	\ CANCELLA LE PAROLE NEL DISPLAY LCD
						RESTART_CODICE 	\ CANCELLA I TASTI GIA PREMUTI E MEMORIZZATI IN CODICE
						DROP
					ELSE 	
						TASTI_KEYPAD DROP + C@ DUP 	\DETERMINA IL TASTO PREMUTO
						CODICE INDICE @ + C! 		\ASSEGNA IL TASTO ALL'ARRAY CODICE
						SEND_DATA 					\STAMPA NEL DISPLAY LCD IL TASTO PREMUTO
						1 INDICE ++I
					THEN
				  THEN ;					


\ VARIABILE CHE MEMORIZZA IL TEMPO IN CUI È STATO MOSTRATO IL MESSAGGIO DI CONFERMA
\ UTILIZZATA PER RESETTARE IL SISTEMA SE NON SI CONFERMA ENTRO 6 SECONDI
VARIABLE TEMPO

\ MOSTRA NEL DISPLAY LCD IL MESSAGGIO DI CONFERMA CON IL RELATIVO
\ CODICE SELEZIONATO
: DISPLAY_CONFERMA CLEAR_DISPLAY MEX_CONFERMA STAMPA_MESSAGGIO
				   0 CONTATORE !
				   BEGIN 
						CODICE CONTATORE @ + \ STAMPA NEL DISPLAY LCD IL CODICE SELEZIONATO
						   C@ SEND_DATA
						1 CONTATORE ++I
						CONTATORE @ 
				   3 = UNTIL 
				   1 FLAG ! 			\ IMPOSTA A 1 IL FLAG PER IL CONTROLLO DEI 6 SECONDI
				   TIMESTAMP TEMPO ! ; 	\ MEMORIZZA IL TEMPO DI INZIO DEI 6 SECONDI


\ FLAG UTILIZZATI PER VERIFICARE LA CORRISPONDENZA TRA
\ I CODICI DEI PRODOTTI E QUELLI INSERITI DALL'UTENTE
VARIABLE COD1
VARIABLE COD2
VARIABLE COD3

: AZZERA_COD 0 COD1 ! 0 COD2 ! 0 COD3 ! ;

\ VARIABILE UTILIZZATA PER SPOSTARSI ALL'INTERNO DELLA STRINGA PRODOTTI DI MULTIPLI DI 3,
\ PER AGGIORNARE LE QUANTITÁ DEI PRODOTTI E PER DETERMINARE LE CORDINATE DEI PIXEL DI PARTENZA
\ DEGLI ELEMENTI DA STAMPARE NEL MONITOR HDMI
VARIABLE I

\ VERIFICA LE CORRISPONDENZE DEI CODICI  
\ ( -- 1/0 )
: TROVA_PRODOTTO AZZERA_COD	 
				 0 I !
				 BEGIN
					0 CONTATORE !
					PRODOTTI DROP CONTATORE @ + I @ + C@ \ RESTITUISCE IL PRIMO CARATTERE DI OGNI CODICE POSSIBILE 
					CODICE CONTATORE @ + C@				 \ RESTITUISCE IL PRIMO CARATTERE SELEZIONATO DALL'UTENTE
					= IF 								 \ CONTROLLA SE I DUE CARATTERI SONO UGUALI
						1 COD1 !
					ELSE 
						0 COD1 !
					THEN
					1 CONTATORE !
					PRODOTTI DROP CONTATORE @ + I @ + C@ \ RESTITUISCE IL SECONDO CARATTERE DI OGNI CODICE POSSIBILE 
					CODICE CONTATORE @ + C@				 \ RESTITUISCE IL SECONDO CARATTERE SELEZIONATO DALL'UTENTE
					= IF								 \ CONTROLLA SE I DUE CARATTERI SONO UGUALI
						1 COD2 !
					ELSE 
						0 COD2 !
					THEN
					2 CONTATORE !
					PRODOTTI DROP CONTATORE @ + I @ + C@ \ RESTITUISCE IL TERZO CARATTERE DI OGNI CODICE POSSIBILE 
					CODICE CONTATORE @ + C@ 			 \ RESTITUISCE IL TERZO CARATTERE SELEZIONATO DALL'UTENTE
					= IF								 \ CONTROLLA SE I DUE CARATTERI SONO UGUALI
						1 COD3 !
					ELSE 
						0 COD3 !
					THEN
					COD1 @ COD2 @ COD3 @ AND AND \ VERIFICA SE TUTTI E TRE I CARATTERI PREMUTI DALL'UTENTE CORRISPONDO AD UN CODICE AMMISSIBILE
					IF 1 
					ELSE \SE NON È STATA TROVATA UNA CORRISPONDENZA SI INCREMENTA DI TRE LA VARIABILE I PER SPOSTARSI TRA I CODICI AMMISSIBILI
						I @ 9 = IF 1 \ VERIFICA SE ABBIAMO CONTROLLATO TUTTI I CODICI AMMISSIBILI
						ELSE						
						3 I ++I 0
						THEN
					THEN
				 1 = UNTIL 
				 COD1 @ COD2 @ COD3 @ AND AND \ LASCIA SULLO STACK IL VALORE 0/1 PER INDICARE L'ESISTENZA O MENO DEL CODICE SELEZIONATO
				 AZZERA_COD ;


\ VARIABILE CONTENENTE LE QUANTITÁ DEI PRIMI 3 PRODOTTI
CREATE QUANTITA 2 ALLOT ALIGN

\ PAROLA CHE POPOLA LE RISPETTIVE QUANTITÁ
: SET_QUANTITA 0 CONTATORE !
				BEGIN 
					10 QUANTITA CONTATORE @ + C!
					1 CONTATORE ++I
				CONTATORE @ 3 = UNTIL ;

SET_QUANTITA

\ FLAG UTILIZZATO PER DETERMINARE QUANDO È POSSIBILE UTILIZZARE IL SENSORE AD ULTRASUONI
VARIABLE FLAG_SONIC
1 FLAG_SONIC !
: VERIFICA_ULTRASUONI SONIC \ RITORNA IL TEMPO IMPIEGATO DAL SUONO PER RICONOSCERE L'OSTACOLO
					  2000 < IF \ SE LA DISTANZA È MINORE DI CIRCA 35 CM IL PRODOTTO È DISPONIBILE
					  1 ELSE 	\ SE IL TEMPO È MAGGIORE DI 2000 US
						0 0 FLAG_SONIC ! \ IL RPODOTTO NON È DISPONIBILE E VIENE DISABILITATA LA POSSIBILITÁ DI RICONTROLLARLO
					  THEN ;

\ COTROLLA SE IL PRODOTTO SELEZIONATO È DISPONIBILE
\ ( -- N/0 )
: DISPONIBILITA I @ 3 / DUP \ CONTROLLA QUALE DEI 4 PRODOTTI L'UTENTE HA SELEZIONATO
				3 = IF 		\ QUARTO PRODOTTO CONTROLLATO DALL'ULTRASUONI
					FLAG_SONIC @ IF \ CONTROLLA SE IL FLAG_SONIC È ABILITATO
						DROP VERIFICA_ULTRASUONI
					ELSE 0
					THEN	
				ELSE 				\ SE IL PRODOTTO È UNO DEI PRIMI TRE
					QUANTITA + C@ 	\ RESTITUISCE LA QUANTITÁ RIMANENTE DEL PRODOTTO SELEZIONATO
				THEN ;


VARIABLE INDEX \ UTILIZZATA PER SCORERE L'ARRAY CONTENENTE I VALORI PER LA STAMPA NEL MONITOR HDMI

\ VETTORE CONTENENTE LE POSIZIONI DEI 4 OGGETTI DA MOSTRARE NEL MONITOR HDMI 
\ PER OGNI OGGETTO VENGONO UTILIZZATE 3 COPPIE DI CORDINATE (X,Y) CHE INDICANO IL 
\ NUMERO DI RIGA E DI COLONNA IN CUI È SITUATO IL PIXEL DI PARTENZA
CREATE POSIZIONE
189 , 146 , 189 , 173 , 189 , 296 , \ CORDINATE X Y DEL PRIMO OGGETT0
696 , 146 , 696 , 173 , 696 , 296 , \ CORDINATE X Y DEL SECONDO OGGETT0
189 , 537 , 189 , 564 , 189 , 687 , \ CORDINATE X Y DEL TERZO OGGETT0
696 , 537 , 696 , 564 , 696 , 687 , \ CORDINATE X Y DEL QUARTO OGGETT0

\ PAROLA CHE DETERMINA LA POSIZIONE DEL PIXEL DI PARTENZA IN CORDINATE (POSX,POSY) 
\ PER LA RAPPRESENTAZIONE DI OGNUNO DEI 4 OGGETTI. IN INPUT PRENDE UN NUMERO CHE PUÒ ESSERE
\ 0 2 4 INDICANTE QUALE COPPIA DELLE 3 X Y, DEFINITE PER OGNI OGGETTO NEL VETTORE POSIZIONE 
\ UTILIZZARE, LA PAROLA POSIZIONI INOLTRE UTILIZZA IL VALORE CONTENUTO NELLA VARIABILE I 
\ PER DETERMINARE A QUALE DEI 4 PRODOTTI CI STIAMO RIFERENDO  
\ (0/2/4 -- POSX POSY )
: POSIZIONI I @ 3 / 6 * + 4 * POSIZIONE + DUP @ SWAP 4 + @  ;

\ PAROLA UTILIZZATA ALL'AVVIO DEL MONITOR HDMI PER RAPPRESENTARE IN ESSO TUTTI E 4 GLI OGGETTI
: INIT_OGG_HDMI 0 I !
				BEGIN 
					GIALLO 161 27 
					POSIZIONE I @ 4 * + @ POSIZIONE I @ 1 + 4 * + @ RETTANGOLO
					ROSSO 161 123 
					POSIZIONE I @ 2 + 4 * + @ POSIZIONE I @ 3 + 4 * + @ RETTANGOLO
					GIALLO 161 27 
					POSIZIONE I @ 4 + 4 * + @ POSIZIONE I @ 5 + 4 * + @ RETTANGOLO
					6 I ++I
				I @ 24 = UNTIL ;

\ LE PAROLE CANCELLA_OGGETTO E STAMPA_OGGETTO SONO UTILIZZATE IN FASE DI EROGAZIONE PER CANCELLARE
\ L'OGGETTO EROGATO E PER RISTAMPARLO NEL CASO IN CUI ESSO SIA ANCORA DISPONIBILE
\ LE DUE PAROLE UTILIZZANO LA PAROLA POSIZIONI PER DETERMINARE LE COORDINATE DELL'OGGETTO
\ SELEZIONATO DALL'UTENTE
: STAMPA_OGGETTO GIALLO 161 27 0 POSIZIONI RETTANGOLO
				 ROSSO 161 123 2 POSIZIONI RETTANGOLO
				 GIALLO 161 27 4 POSIZIONI RETTANGOLO ;

: CANCELLA_OGGETTO BIANCO 161 27 0 POSIZIONI RETTANGOLO
				   BIANCO 161 123 2 POSIZIONI RETTANGOLO
				   BIANCO 161 27 4 POSIZIONI RETTANGOLO ;

\ PAROLA UTILIZZATA ALL'AVVIO DEL SISTEMA PER RAPPRESENTARE NEL MONITOR HDMI 
\LE VARIE COMPONENTI DEL DISTRIBUTORE
: START_HDMI 0 INDEX !
			 BEGIN
				DISTRIBUTORE INDEX @ 4 * + @	\ CARICHIAMO NELLO STACK 5 ELEMENTI CONSECUTIVI CONTENUTI NEL VETTORE DISTRIBUTORE
				INDEX @ 5 MOD 					\ CHE INDICANO (COLORE REL_WIDTH REL_HEIGHT POSX POSY) DI OGNI ELEMENTO DA RAPPRESENTARE
				4 = IF RETTANGOLO THEN
				1 INDEX ++I
			INDEX @ 50 = UNTIL
			CODICE1 CODICE2 CODICE3 CODICE4		\ PAROLE CHE RAPPRESENTANO I CODICI RELATIVI AD OGNI OGGETTO
			INIT_OGG_HDMI ;


\ DETERMINA SE È POSSIBILE OTTENERE IL PRODOTTO SELEZIONATO
: CONFERMA 	TROVA_PRODOTTO 					\ VERIFICA SE IL CODICE SELEZIONATO È AMMISSIBILE
			IF 								\ SE LO È
				DISPONIBILITA				\ CONTROLLA SE IL PRODOTTO È ANCORA DISPONIBILE
				0 > IF 							
					DISPLAY_CONFERMA		\ STAMPA IL MESSAGGIO DI CONFERMA
				ELSE
					CLEAR_DISPLAY
					MEX_NO_DISP STAMPA_MESSAGGIO \ STAMPA IL MESSAGGIO NON DISPONIBILE 
					3000000 DELAY					
					START_DISPLAY				 \ IL SISTEMA RIPARTE DALLO STATO DELLA SELEZIONE DI UN NUOVO PRODOTTO 
					RESTART_CODICE
				THEN
			ELSE 
				CLEAR_DISPLAY
				MEX_ERROR STAMPA_MESSAGGIO		\ IL SISTEMA STAMPA IL MESSAGGIO CODICE ERRATO
				3000000 DELAY
				START_DISPLAY					\ IL SISTEMA RIPARTE DALLO STATO DELLA SELEZIONE DI UN NUOVO PRODOTTO
				RESTART_CODICE
			THEN ;

\ PAROLA CHE STAMPA IL MESSAGGIO, DECREMENTA LA QUANTITÁ CORRISPONDENTE
\ AL PRODOTTO SELEZIONATO E SIMULA L'EROGAZIONE AZIONANDO IL SERVO MOTORE
: EROGAZIONE CLEAR_DISPLAY MEX_EROGAZIONE STAMPA_MESSAGGIO
			 I @ 3 / DUP 3 < IF 	\ DETERMINA SE IL PRODOTTO SELEZIONATO DIPENDE DAL SENSORE AD ULTRASUONI O MENO
				ROT_SERVO_0_180		\ SPOSTA IL SERVO DA 0 A 180 GRADI 
				CANCELLA_OGGETTO	
				DUP QUANTITA + DUP C@ 1 - SWAP C! \DECREMENTA IL VALORE CHE CONTIENE IL NUMERO DI PRODOTTI DISPONIBILI
				QUANTITA + C@
				ROT_SERVO_180_0		\ RIPORTA IL SERVO NELLA POSIZIONE INIZIALE
				0 > IF 				\ CONTROLLA SE PER IL PRODOTTO EROGATO VI SONO ANCORA PRODOTTI DISPONIBILI
				STAMPA_OGGETTO THEN \ IN CASO AFFERMATIVO LO MOSTRA NEL MONITOR HDMI
			 ELSE 					\ SE IL PRODOTTO SELEZIONATO DIPENDE DAL SENSORE AD ULTRASUONI
				DROP 
				ROT_SERVO_0_180		\ SPOSTA IL SERVO DA 0 A 180 GRADI
				CANCELLA_OGGETTO 
				VERIFICA_ULTRASUONI \ CONTROLLA SE DOPO L'EROGAZIONE IL PRODOTTO È ANCORA DISPONIBILE
				ROT_SERVO_180_0		\ RIPORTA IL SERVO NELLA POSIZIONE INIZIALE
				IF STAMPA_OGGETTO THEN \ SE È DISPONIBILE LO MOSTRA NEL MONITOR HDMI
			 THEN ;
			 

\ PAROLA CHE DOPO AVER ATTESO IL RILASCIO DEL TASTO DA PARTE DELL'UTENTE,
\ DETERMINA IL COMPORTAMENTO DEL SISTEMA DIPENDENTEMENTE DAL TASTO PREMUTO
\ ( GPIO_ROW -- )
: KEY_UP BEGIN DUP READLEV 1 = UNTIL DROP	\ ATTESA DEL RILASCIO DEL TASTO ( GPIO_ROW -- )
		 INDICE @ DUP 
		 2 < IF 							\ SE L'UTENTE STA INSERENDO I PRIMI DUE CARATTERI DEL CODICE
			DROP MEMORIZZA_TASTO 			\ DEL PRODOTTO IL SISTEMA ANALIZZA E MEMORIZZA IL TASTO PREMUTO
		 ELSE
			2 = IF							\ SE L'UTENTE PREME IL TERZO CARATTERE IL SISTEMA CONTROLLA 
				TASTO_PREMUTO DUP			\ SE PRIMA SE È UN CARATTERE SPECIALE IN CASO AFFERMATIVO
				12 = SWAP 14 = OR 			\ * = RESTART E # = SPEGNI SISTEMA
				IF							\ DOVE IL COMPORTAMENTO VIENE DETERMINATO IN MEMORIZZA_TASTO
					MEMORIZZA_TASTO			
				ELSE						\ SE IL TERZO CARATTERE NON È UN CARATTERE SPECIALE ESSO VIENE
					MEMORIZZA_TASTO			\ MEMORIZZATO E VIENE AVVIATA LA PROCEDURA PER LA CONFERMA
					CONFERMA 
				THEN
			ELSE							\ SIAMO NELLO STATO DELLA CONFERMA PRODOTTO:
				TASTO_PREMUTO DUP			\ CONTROLLO DEL TASTO PREMUTO
				15 = IF						\ SE IL TASTO PREMUTO È UGUALE A "D" CIOÈ IL PRODOTTO VIENE CONFERMATO: 
					DROP					
					0 FLAG !				\ VIENE INTERROTTO IL CONTROLLO DEI SEI SECONDI
					EROGAZIONE				\ VIENE AVVIATA LA SIMULAZIONE DELL'EROGAZIONE AL TERMINE DELLA QUALE
					START_DISPLAY			\ IL SISTEMA RIPARTE DALLO STATO DELLA SELEZIONE DI UN NUOVO PRODOTTO
					RESTART_CODICE			\ CANCELLA IL CODICE SELEZIONATO
					SEGNALE_PWM_L			\ INTERROMPE IL SEGNALE PWM
				ELSE 
					12 = IF					\ SE IL TASTO PREMUTO È "*" IL SISTEMA RIPARTE DALLO STATO DELLA SELEZIONE DI UN NUOVO PRODOTTO
						0 FLAG !
						MEMORIZZA_TASTO
					THEN	                \ SE IL TASTO PREMUTO È DIVERSO DA "D" O DA "*" IL SISTEMA RESTA IN ATTESA DEL
				THEN						\ TASTO CORRETTO FINO ALLO SCADERE DEI SEI SECONDI
			THEN
		 THEN ;

\ VARIABILE UTILIZZATA PER SPOSTARSI TRA LE RIGHE E COLONNE DEL KEYPAD
VARIABLE COUNT

\ PAROLA CHE DETERMINA LA RIGA E LA COLONNA KEYPAD DEL TASTO PREMUTO DALL'UTENTE 
\ ( -- GPIO_ROW )
: KEY_DOWN  0 COUNT !
			BEGIN 
				1 KM_COL1 COUNT @ - DUP COLONNA ! GPIOCLR_LOG 	\ SCORRE LE COLONNE E PER OGNUNA DI ESSE SETTA IL REG-CLR A 1
				1 BEGIN 
					DUP >R 1 + DUP RIGA ! DUP READLEV 			\ CONTROLLA SE VI È UNA RIGA NELLO STATO DI CLEAR  
					0 = IF 										\ IN CASO AFFERMATIVO ABBIAMO DETERMINATO IL TASTO PREMUTO
						KEY_UP ELSE DROP 
					THEN
					R> 1 + DUP 
				5 = UNTIL 
				DROP 											\ QUANDO IL CODICE TERMINA DI CONTROLLARE LE RIGHE DELLA COLONNA SELEZIONATA
				1 KM_COL1 COUNT @ - GPIOSET_LOG					\ IMPOSTA IL SUO REGISTRO SET A 1
				1 COUNT ++I
				COUNT @
		    4 = UNTIL ;


\ PAROLA UTILIZZATA PER AVVIARE IL SISTEMA, IL SISTEMA RESTERÁ ALL'INTERNO DI
\ UN LOOP FINTANTOCHÈ IL SISTEMA NON VIENE SPENTO PREMENDO IL TASTO "#" CHE IMPOSTA
\ IL FLAG SPEGNI A 1
: MAIN 	START_HDMI
		START_DISPLAY
		BEGIN 
			KEY_DOWN
			FLAG @ 1 = IF			\ CONTROLLO CHE VIENE AVVIATO SOLO SE IL SISTEMA SI TROVA NELLO 
				TIMESTAMP TEMPO @ - \ STATO DI CONFERMA PRODOTTO, IN QUESTA FASE IL SISTEMA ASPETTA 
				6000000 > IF		\ UNA RISPOSTA DALL'UTENTE PER SEI SECONDI
					START_DISPLAY 	\ QUANDO IL TEMPO VIENE SUPERATO IL SISTEMA RITORNA NELLA 
					RESTART_CODICE	\ CONDIZIONE DI RICEVERE UN NUOVO CODICE				
					0 FLAG !
				THEN
			THEN	
		SPEGNI @ 
		UNTIL						\ ALL'USCITA DAL LOOP DEL MAIN LE INFORMAZIONI MANTENUTE DAL SISTEMA 
		RESTART_CODICE				\ VENGONO RESETTATE
		1 FLAG_SONIC !
		0 SPEGNI ! ;
		
		
		
