20000 CONSTANT M_ATTESA \DEVE TENERE IL GPIO DATA IN USCITA BASSA PER ALMENO 18 MS, DOPO DEVE RIPORTARE IL GPIO IN INGRESSO
160 CONSTANT S_ATTESA \IL SENSORE ATTENDE 160 US PRIMA DI COMINCIARE AD INVIRAE I DATI
40 CONSTANT N_BITS \ [High humidity (8 BITS) - Low humidity (8 BITS) - High temp (8 BITS) - Low temp (8 BITS) - Parity bit (8 BITS)]
0 VARIABLE ACC


CREATE DATI N_BITS 1 - ALLOT ALIGN

\COMANDO PER COMUNICARE AL SENSORE CHE IL MICROCONTROLLORE E' PRONTO A RICEVERE I DATI
\ ( STANZA -- STANZA GPIO )                           (STANZA GPIO GPIO GPIO GPIO)                               (STANZA GPIO)
: START DUP THERMOS SWAP AREAD DUP 2DUP DUP CLRGPIO  001  ABILPIN  CLRGPIO M_ATTESA DELAY 000 ABILPIN ;


\COMANDO PER ATTENDERE CHE IL SENSORE INIZI A COMUNICARE
\ ( -- )
: WAIT S_ATTESA DELAY ;

\COMANDO DI PROVA 
\ ( -- )
: DELAY_R S_ATTESA TIMESTAMP BEGIN ROT DUP READLEV . ROT ROT 2DUP TIMESTAMP SWAP - <= UNTIL 2DROP ;


\FUNZIONE CHE RITORNA FALSE (0) QUANDO LETX=0 E LETY=1 ALTRIMENTI RITORNA TRUE (1)
\ (LETX LETY -- BOOL)
: SWITCHED 1 = SWAP 0 = AND 1 = IF 0 ELSE 1 THEN ;


\ RILEVA E MEMORIZZA NELL'ARRAY DATI[N] L'ENNESIMO VALORE COMUNICATO DAL SENSORE
\ (GPIO ACC  -- )
: ZERONEREAD SWAP 2DUP 40 DELAY READLEV DATI ROT ASTORE   ;

\LETTURA DATI GPLEV
\( STANZA GPIO -- STANZA GPIO)
: READS BEGIN N_BITS ACC @ - 1 - WHILE BEGIN DUP DUP READLEV SWAP READLEV SWITCHED WHILE REPEAT ACC @  ZERONEREAD 1 SWAP ADDC REPEAT ;


\( STANZA -- )
: RILEVAZIONE START WAIT READS ;

\ 0 RILEVAZIONE


\SOMMA MODULO DUE
\ (N1 N2 N3 N4 -- N) DA VEDERE SE ESISTE */MOD
: MOD2SUM + + + 1 2 */MOD DROP  ;