
DECIMAL

20000 CONSTANT M_ATTESA \DEVE TENERE IL GPIO DATA IN USCITA BASSA PER ALMENO 18 MS, DOPO DEVE RIPORTARE IL GPIO IN INGRESSO
160 CONSTANT S_ATTESA \IL SENSORE ATTENDE 160 US PRIMA DI COMINCIARE AD INVIRAE I DATI
40 CONSTANT N_BITS \ [High humidity (8 BITS) - Low humidity (8 BITS) - High temp (8 BITS) - Low temp (8 BITS) - Parity bit (8 BITS)]
4800 CONSTANT ALT \ DURATA MASSIMA INTERA TRASMISSIONE
80 CONSTANT 1END \ 

VARIABLE TI1 \TEMPO INIZIALE
VARIABLE TI2

VARIABLE ACC
VARIABLE OFFSET
VARIABLE BASE
VARIABLE HHUMIDITY
VARIABLE HTEMPERATURE
VARIABLE LHUMIDITY
VARIABLE LTEMPERATURE  
VARIABLE PARITY

CREATE DATI N_BITS 1 - ALLOT ALIGN

\ INIZIALIZZAZIONE VARIABILE ACC CON VALORE 0
\ ( -- )
: INITACC 0 ACC ! ;
: INITOFF 32 OFFSET ! ;
: INITBASE 7 BASE ! ;
: INITTI1 TIMESTAMP TI1 ! ;
: INITTI2 TIMESTAMP TI2 ! ;

\COMANDO PER COMUNICARE AL SENSORE CHE IL MICROCONTROLLORE E' PRONTO A RICEVERE I DATI
\ ( STANZA -- STANZA GPIO )                           (STANZA GPIO GPIO GPIO GPIO)                               (STANZA GPIO)
: START DUP THERMOS SWAP AREAD DUP 2DUP DUP CLRGPIO  001  ABILPIN  CLRGPIO M_ATTESA DELAY 000 ABILPIN ;


\COMANDO PER ATTENDERE CHE IL SENSORE INIZI A COMUNICARE
\ (-- )
: WAITP DUP DUP READLEV 100 DELAY SWAP READLEV 60 DELAY . . ;
: WAIT S_ATTESA DELAY ;

\COMANDO DI PROVA 
\ ( -- )
\: DELAY_R S_ATTESA TIMESTAMP BEGIN ROT DUP READLEV . ROT ROT 2DUP TIMESTAMP SWAP - <= UNTIL 2DROP ;


\FUNZIONE CHE RITORNA FALSE (0) QUANDO LETX=0 E LETY=1 ALTRIMENTI RITORNA TRUE (1)
\ (LETX LETY -- BOOL)
: SWITCHED 1 = SWAP 0 = AND -1 = IF 0 ELSE -1 THEN ;


\ RILEVA E MEMORIZZA NELL'ARRAY DATI[N] L'ENNESIMO VALORE COMUNICATO DAL SENSORE
\ (GPIO ACC  -- GPIO ACC )
: ZERONEREAD SWAP 2DUP 29 DELAY READLEV DUP 0 = IF DATI ROT ASTORE  ELSE DATI ROT ASTORE INITTI2 BEGIN DUP READLEV 1 = TIMESTAMP TI2 @ - 1END < AND WHILE REPEAT THEN SWAP DROP ;

\LETTURA DATI GPLEV
\( STANZA GPIO -- STANZA GPIO)
: READS INITACC INITTI1 BEGIN ACC @ N_BITS < TIMESTAMP TI1 @ - ALT < AND  WHILE BEGIN DUP READLEV  0 = WHILE REPEAT ACC @  ZERONEREAD 1 ACC ADDC REPEAT  ACC @ . ;
\: READS INITACC INITTI BEGIN ACC @ N_BITS < TIMESTAMP TI @ - ALT < AND WHILE DUP READLEV SWAP  1 ACC ADDC REPEAT ACC @ . ;
\: READS INITACC BEGIN ACC @ N_BITS < WHILE BEGIN DUP READLEV  0 = WHILE REPEAT ACC @  ZERONEREAD 1 SWAP ADDC REPEAT  ACC @ . ;

\( STANZA -- )
: RILEVAZIONE START WAIT READS ;

\ 0 RILEVAZIONE

\EFFETTUA LA VERIFICA ATTRAVERSO PARITY BIT
\ ( -- BOLL) ( DA MODIFICARE)
\: CHECKSUM INITACC BEGIN ACC @ 8 < WHILE INITOFF BEGIN OFFSET @ 0 >= WHILE DATI ACC @ OFFSET @ + AREAD 8 OFFSET DECC REPEAT XOR XOR XOR = IF 1 ACC ADDC ELSE 10 ACC ADDC THEN  REPEAT ACC @ . ACC @ 8 = IF 1 ELSE 0 THEN ;

( DATI VAL_ACC OFFSET  -- VAL_DEC)
: READ ;
DATI 0 8 READ

\LETTURA UMIDITA
\ ( -- VALORE)
\: READHUMIDITY CHECKSUM IF INITBASE INITACC BEGIN ACC @ 8 < WHILE DATI ACC @ AREAD BASE @ LSHIFT  1 BASE DECC  1 ACC ADDC REPEAT + + + + + + + HUMIDITY ! ELSE 0 THEN ;
: READHUMIDITY INITBASE INITACC BEGIN ACC @ 8 < WHILE DATI ACC @ AREAD BASE @ LSHIFT  1 BASE DECC  1 ACC ADDC REPEAT + + + + + + + HHUMIDITY ! ;

\lETTURA TEMPERATURA
\ ( -- VALORE )
\: READTEMP CHECKSUM IF INITBASE INITACC BEGIN ACC @ 16 + 24 < WHILE DATI ACC @ 16 + AREAD BASE @ LSHIFT  1 BASE DECC  1 ACC ADDC REPEAT + + + + + + + TEMPERATURE ! ELSE 0 THEN ;
: READTEMP  INITBASE INITACC BEGIN ACC @ 16 + 24 < WHILE DATI ACC @ 16 + AREAD BASE @ LSHIFT  1 BASE DECC  1 ACC ADDC REPEAT + + + + + + + HTEMPERATURE !  ;


